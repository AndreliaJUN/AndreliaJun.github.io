<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="JavaScript面向对象编程(原型详解)"><meta name="keywords" content="JavaScript"><meta name="author" content="Andrelia,undefined"><meta name="copyright" content="Andrelia"><title>JavaScript面向对象编程(原型详解)【Andrelia的秘密花园】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript面向对象编程"><span class="toc-number">1.</span> <span class="toc-text">JavaScript面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是对象："><span class="toc-number">1.1.</span> <span class="toc-text">什么是对象：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是面向对象："><span class="toc-number">1.2.</span> <span class="toc-text">什么是面向对象：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象与面向过程："><span class="toc-number">1.3.</span> <span class="toc-text">面向对象与面向过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象的特性："><span class="toc-number">1.4.</span> <span class="toc-text">面向对象的特性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建对象的方法："><span class="toc-number">1.5.</span> <span class="toc-text">创建对象的方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数的问题"><span class="toc-number">1.5.1.</span> <span class="toc-text">构造函数的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型"><span class="toc-number">1.6.</span> <span class="toc-text">原型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数、实例、原型三者之间的关系"><span class="toc-number">1.6.1.</span> <span class="toc-text">构造函数、实例、原型三者之间的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#利用原型共享数据"><span class="toc-number">1.6.2.</span> <span class="toc-text">利用原型共享数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性成员的搜索原则：原型链"><span class="toc-number">1.6.3.</span> <span class="toc-text">属性成员的搜索原则：原型链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更简单的原型语法"><span class="toc-number">1.6.4.</span> <span class="toc-text">更简单的原型语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原型对象使用建议"><span class="toc-number">1.6.5.</span> <span class="toc-text">原型对象使用建议</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/sijia1.jpg"></div><div class="author-info-name">Andrelia</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/AndreliaJUN" target="_blank">GitHub<i class="icon-dot bg-color10"></i></a><a class="links-button button-hover" href="https://blog.csdn.net/Andrelia20171760" target="_blank">CSDN<i class="icon-dot bg-color5"></i></a><a class="links-button button-hover" href="http://www.andrelia.cn" target="_blank">PersonalSite<i class="icon-dot bg-color1"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">4</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">4</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">3</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">Andrelia的秘密花园</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">JavaScript面向对象编程(原型详解)</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-10-12 | 更新于 2019-10-12</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/JavaScript/">JavaScript</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/JavaScript/">JavaScript</a></div></div></div><div class="main-content"><h2 id="JavaScript面向对象编程"><a href="#JavaScript面向对象编程" class="headerlink" title="JavaScript面向对象编程"></a>JavaScript面向对象编程</h2><h3 id="什么是对象："><a href="#什么是对象：" class="headerlink" title="什么是对象："></a>什么是对象：</h3><p>ECMAScript-262 把对象定义为：<strong>无序属性的集合，其属性可以包含基本值、对象或者函数</strong>。</p>
<p>严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。</p>
<blockquote>
<p>提示：每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型。</p>
</blockquote>
<h3 id="什么是面向对象："><a href="#什么是面向对象：" class="headerlink" title="什么是面向对象："></a>什么是面向对象：</h3><blockquote>
<p>面向对象不是新的东西，它只是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。</p>
</blockquote>
<h3 id="面向对象与面向过程："><a href="#面向对象与面向过程：" class="headerlink" title="面向对象与面向过程："></a>面向对象与面向过程：</h3><ul>
<li><p>面向过程就是亲力亲为，事无巨细，面面俱到，步步紧跟，有条不紊</p>
</li>
<li><p>面向对象就是找一个对象，指挥得结果</p>
</li>
<li><p>面向对象将执行者转变成指挥者</p>
</li>
<li><p>面向对象不是面向过程的替代，而是面向过程的封装</p>
</li>
<li><p>面向过程注重过程，面向对象注重结果</p>
</li>
</ul>
<h3 id="面向对象的特性："><a href="#面向对象的特性：" class="headerlink" title="面向对象的特性："></a>面向对象的特性：</h3><ul>
<li>封装性</li>
<li>继承性</li>
<li>多态性</li>
</ul>
<p>在 JavaScript 中，所有数据类型都可以视为对象，当然也可以自定义对象。</p>
<p>自定义的对象数据类型就是面向对象中的类（ Class ）的概念。</p>
<h3 id="创建对象的方法："><a href="#创建对象的方法：" class="headerlink" title="创建对象的方法："></a>创建对象的方法：</h3><ul>
<li><p><strong>new Object()</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">'Jack'</span></span><br><span class="line">person.age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次都new比较麻烦，所以可以通过简写形式即对象字面量来创建。</p>
</li>
<li><p><strong>对象字面量方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的写法固然没有问题，但是假如我们要生成两个 <code>person</code> 实例对象呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">'Mike'</span>,</span><br><span class="line">  age: <span class="number">16</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们不难看出，这样写的代码太过冗余，重复性太高。</p>
</li>
</ul>
<p>  <strong>简单方式的改进：工厂函数</strong></p>
<p>  我们可以写一个函数，解决代码重复问题：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  然后生成实例对象：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">'Jack'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = createPerson(<span class="string">'Mike'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p>  这样封装确实爽多了，通过工厂模式我们解决了创建多个相似对象代码冗余的问题，</p>
<p>  但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</p>
<p>  那么就有更优雅的工厂函数：构造函数。</p>
<ul>
<li><strong>自定义构造函数</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="number">18</span>)</span><br><span class="line">p1.sayName() <span class="comment">// =&gt; Jack</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'Mike'</span>, <span class="number">23</span>)</span><br><span class="line">p2.sayName() <span class="comment">// =&gt; Mike</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Person()</code> 函数取代了 <code>createPerson()</code> 函数，但是实现效果是一样的。</p>
<p><strong>工厂模式和自定义构造函数的相同点与不同点</strong></p>
<p>共同点:都是函数,都可以创建对象,都可以传入参数</p>
<p>不同点：</p>
<ul>
<li><p>工厂模式:</p>
<ul>
<li>函数名是小写</li>
<li>有new</li>
<li>有返回值</li>
<li>new之后的对象是当前的对象</li>
<li>直接调用函数就可以创建对象</li>
</ul>
</li>
<li><p>自定义构造函数:</p>
<ul>
<li>函数名是大写(首字母)</li>
<li>没有new</li>
<li>没有返回值</li>
<li>this是当前的对象</li>
<li>通过new的方式来创建对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>- 没有显示的创建对象</p>
<p>- 直接将属性和方法赋给了 <code>this</code> 对象</p>
<p>- 没有 <code>return</code> 语句</p>
<p>- 函数名使用的是大写的 <code>Person</code></p>
</blockquote>
<p><strong>调用构造函数创建实例会经历以下 4 个步骤：</strong></p>
<ol>
<li><p>开辟空间存储对象</p>
</li>
<li><p>把this设置为当前的对象</p>
</li>
</ol>
<p>​    3. 设置属性和方法的值</p>
<pre><code>4. 把this对象返回</code></pre><p><strong>构造函数和实例对象的关系</strong></p>
<p>使用构造函数的好处不仅仅在于代码的简洁性，更重要的是我们可以识别对象的具体类型了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,sex</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name=name;</span><br><span class="line">      <span class="keyword">this</span>.age=age;</span><br><span class="line">      <span class="keyword">this</span>.sex=sex;</span><br><span class="line">      <span class="keyword">this</span>.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"吃肉肉"</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> girl=<span class="keyword">new</span> Person(<span class="string">"小明"</span>,<span class="number">20</span>,<span class="string">"女"</span>);</span><br><span class="line">     <span class="built_in">console</span>.dir(girl);</span><br><span class="line">     <span class="built_in">console</span>.dir(Person);</span><br></pre></td></tr></table></figure>

<p>控制台显示如下：</p>
<img src="/2019/10/12/原型/1.png" style="zoom:75%;">

<p>在每一个实例对象中的__proto__中同时有一个 <code>constructor</code> 属性,，该属性指向创建该实例的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(girl.constructor==Person);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(girl.__proto__.constructor==Person);</span><br><span class="line">  <span class="built_in">console</span>.log(girl.__proto__.constructor==Person.prototype.constructor);</span><br><span class="line">  <span class="comment">//console.log(girl instanceof Person);</span></span><br></pre></td></tr></table></figure>

<p>以上控制台都打印true，代表这个实例对象girl就是通过Person来创建的。所以我们也可以用它来检测对象的类型。</p>
<p><strong>检测对象类型的方法</strong></p>
<ul>
<li><p>通过构造器的方式 实例对象.构造器==构造函数名字</p>
</li>
<li><p>对象 instanceof 构造函数名字</p>
</li>
</ul>
<p>​    *  尽可能的使用第二种方式来识别,为什么?原型讲完再说</p>
<p><strong>总结</strong></p>
<ul>
<li>构造函数是根据具体的事物抽象出来的抽象模板</li>
<li>实例对象是根据抽象的构造函数模板得到的具体实例对象</li>
<li>每一个实例对象都具有一个 <code>constructor</code> 属性，指向创建该实例的构造函数<ul>
<li>注意： <code>constructor</code> 是实例的属性的说法不严谨，具体后面的原型会讲到</li>
</ul>
</li>
<li>可以通过实例的 <code>constructor</code> 属性判断实例和构造函数之间的关系<ul>
<li>注意：这种方式不严谨，推荐使用 <code>instanceof</code> 操作符，后面学原型会解释为什么</li>
</ul>
</li>
</ul>
<h4 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h4><p>使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'human'</span></span><br><span class="line">  <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'lpz'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="number">16</span>)</span><br></pre></td></tr></table></figure>

<p>在该示例中，从表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。<br>那就是对于每一个实例对象，<code>type</code> 和 <code>sayHello</code> 都是一模一样的内容，<br>每一次生成一个实例，都必须为重复的内容，多占用一些内存，如果实例对象很多，会造成极大的内存浪费,创建100个对象就会产生100个sayHello方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(p1.sayHello === p2.sayHello) <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看出这两个实例的sayHello方法不是一个方法。</p>
<p>对于这种问题我们可以把需要共享的函数定义到构造函数外部：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> = <span class="title">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'human'</span></span><br><span class="line">  <span class="keyword">this</span>.sayHello = sayHello</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'lpz'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.sayHello === p2.sayHello) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>这样确实可以了，但是新问题又来了：在全局作用域中定义的函数实际上只能被某个对象调用。更让人无法接受的是如果对象需要定义很多方法，那么就要定义很多个全局函数，这样没有封装性可言了。<br>以上问题都可以使用原型来解决。</p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>Javascript 规定，每一个构造函数都有一个 <code>prototype</code> 属性，指向另一个对象。<br>这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 <code>prototype</code> 对象上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name=name;</span><br><span class="line">     <span class="keyword">this</span>.age=age;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//通过原型来添加方法,解决数据共享,节省内存空间</span></span><br><span class="line">   Person.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"吃凉菜"</span>);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> p1=<span class="keyword">new</span> Person(<span class="string">"小明"</span>,<span class="number">20</span>);</span><br><span class="line">   <span class="keyword">var</span> p2=<span class="keyword">new</span> Person(<span class="string">"小红"</span>,<span class="number">30</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(p1.eat==p2.eat);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.dir(p1);</span><br><span class="line">   <span class="built_in">console</span>.dir(p2);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//实例对象中根本没有eat方法,但是能够使用,因为实例继承了原型的方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.dir(p1);</span><br><span class="line"><span class="built_in">console</span>.dir(p2);</span><br><span class="line"><span class="built_in">console</span>.dir(Person);</span><br><span class="line">p1.__proto__.eat();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p1.__proto__==Person.prototype);</span><br></pre></td></tr></table></figure>

<p>控制台输出<br><img src="/2019/10/12/原型/2.png" alt><br>说明了：</p>
<ul>
<li><p>实例对象中有<strong>proto</strong>这个属性,叫原型,也是一个对象,这个属性是给浏览器使用,不是标准的属性—–&gt;<strong>proto</strong>—–&gt;可以叫原型对象</p>
</li>
<li><p>构造函数中有prototype这个属性,叫原型,也是一个对象,这个属性是给程序员使用,是标准的属性——&gt;prototype—&gt;可以叫原型对象</p>
</li>
<li><p>实例对象的<strong>proto</strong>和构造函数中的prototype相等—&gt;true</p>
</li>
<li><p>又因为实例对象是通过构造函数来创建的,构造函数中有原型对象prototype</p>
</li>
<li><p>实例对象的<strong>proto</strong>指向了构造函数的原型对象prototype</p>
</li>
<li><p><strong>proto</strong>或者是prototype,都是原型对象。</p>
</li>
<li><p>原型的作用:共享数据,节省内存空间</p>
</li>
</ul>
<h4 id="构造函数、实例、原型三者之间的关系"><a href="#构造函数、实例、原型三者之间的关系" class="headerlink" title="构造函数、实例、原型三者之间的关系"></a>构造函数、实例、原型三者之间的关系</h4><p><img src="/2019/10/12/原型/%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt><br>实例中的<strong>proto</strong>指向原型对象prototype，原型对象中的constructor指向构造函数，构造函数中的prototype属性指向原型对象。</p>
<p>注意：任何函数都具有一个 <code>prototype</code> 属性，该属性是一个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(F.prototype) <span class="comment">// =&gt; object</span></span><br><span class="line"></span><br><span class="line">F.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用原型共享数据"><a href="#利用原型共享数据" class="headerlink" title="利用原型共享数据"></a>利用原型共享数据</h4><p>需要共享的数据放在原型里，这样节省内存，不共享的写在构造函数里。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//什么样子的数据是需要写在原型中?</span></span><br><span class="line">    <span class="comment">//需要共享的数据就可以写原型中</span></span><br><span class="line">    <span class="comment">//原型的作用之一:数据共享</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性需要共享,方法也需要共享</span></span><br><span class="line">    <span class="comment">//不需要共享的数据写在构造函数中,需要共享的数据写在原型中</span></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,sex</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name=name;</span><br><span class="line">      <span class="keyword">this</span>.age=age;</span><br><span class="line">      <span class="keyword">this</span>.sex=sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//所有学生的身高都是188,所有人的体重都是55</span></span><br><span class="line">    <span class="comment">//所有学生都要每天写500行代码</span></span><br><span class="line">    <span class="comment">//所有学生每天都要吃一个10斤的西瓜</span></span><br><span class="line">    <span class="comment">//原型对象</span></span><br><span class="line">    Student.prototype.height=<span class="string">"188"</span>;</span><br><span class="line">    Student.prototype.weight=<span class="string">"55kg"</span>;</span><br><span class="line">    Student.prototype.study=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"学习,写500行代码,小菜一碟"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    Student.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"吃一个10斤的西瓜"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//实例化对象,并初始化</span></span><br><span class="line">    <span class="keyword">var</span> stu=<span class="keyword">new</span> Student(<span class="string">"晨光"</span>,<span class="number">57</span>,<span class="string">"女"</span>);</span><br><span class="line">    <span class="built_in">console</span>.dir(Student);</span><br><span class="line">    <span class="built_in">console</span>.dir(stu);</span><br></pre></td></tr></table></figure>

<p>构造函数的 <code>prototype</code> 对象默认都有一个 <code>constructor</code> 属性，指向 <code>prototype</code> 对象所在函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(F.constructor === F) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>通过构造函数得到的实例对象内部会包含一个指向构造函数的 <code>prototype</code> 对象的指针 <code>__proto__</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> F()</span><br><span class="line"><span class="built_in">console</span>.log(instance.__proto__ === F.prototype) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>

<p>  实例对象的<strong>proto</strong>指向了构造函数的原型对象prototype，<br>   <strong>proto</strong>或者是prototype,都是原型对象。</p>
<ul>
<li>实例对象可以直接访问原型对象成员（所有实例都直接或间接继承了原型对象的成员）。</li>
<li>也就是说即使实例没有定义某个方法，如果原型中有这个方法，那么实例就可以用这个方法。</li>
</ul>
<h4 id="属性成员的搜索原则：原型链"><a href="#属性成员的搜索原则：原型链" class="headerlink" title="属性成员的搜索原则：原型链"></a>属性成员的搜索原则：原型链</h4><p>了解了 <strong>构造函数-实例-原型对象</strong> 三者之间的关系后，接下来我们来解释一下为什么实例对象可以访问原型对象中的成员。</p>
<ul>
<li>实例调用某个方法时，是先查看实例本身有没有这个方法如果有调用没有向上查找原型，原型有就调用原型也没有就返回undefined。</li>
</ul>
<p>也就是说，在我们调用 <code>person1.sayName()</code> 的时候，会先后执行两次搜索：</p>
<ul>
<li>首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。</li>
<li>”然后，它继续搜索，再问：“ person1 的原型有 sayName 属性吗？”答：“有。</li>
<li>”于是，它就读取那个保存在原型对象中的函数。</li>
<li>当我们调用 person2.sayName() 时，将会重现相同的搜索过程，得到相同的结果。</li>
</ul>
<p>而这正是多个对象实例共享原型所保存的属性和方法的基本原理。</p>
<p>总结：</p>
<ul>
<li>先在自己身上找，找到即返回</li>
<li>自己身上找不到，则沿着原型链向上查找，找到即返回</li>
<li>如果一直到原型链的末端还没有找到，则返回 <code>undefined</code></li>
</ul>
<h4 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h4><p>我们注意到，前面例子中每添加一个属性和方法就要敲一遍 <code>Person.prototype</code> 。<br>为减少不必要的输入，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  type: <span class="string">'human'</span>,</span><br><span class="line">  sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我叫'</span> + <span class="keyword">this</span>.name + <span class="string">'，我今年'</span> + <span class="keyword">this</span>.age + <span class="string">'岁了'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该示例中，我们将 <code>Person.prototype</code> 重置到了一个新的对象。<br>这样做的好处就是为 <code>Person.prototype</code> 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 <code>constructor</code> 成员。</p>
<p>所以，我们为了保持 <code>constructor</code> 的指向正确，我们需要手动添加constructor。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person, // =&gt; 手动将 <span class="keyword">constructor</span> 指向正确的构造函数</span><br><span class="line">  type: 'human',</span><br><span class="line">  sayHello: function () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我叫'</span> + <span class="keyword">this</span>.name + <span class="string">'，我今年'</span> + <span class="keyword">this</span>.age + <span class="string">'岁了'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="原型对象使用建议"><a href="#原型对象使用建议" class="headerlink" title="原型对象使用建议"></a>原型对象使用建议</h4><ul>
<li>私有成员（一般就是非函数成员）放到构造函数中</li>
<li>共享成员（一般就是函数）放到原型对象中</li>
<li>如果重置了 <code>prototype</code> 记得修正 <code>constructor</code> 的指向</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Andrelia</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://andreliajun.github.io/2019/10/12/原型/">https://andreliajun.github.io/2019/10/12/原型/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://andreliajun.github.io">Andrelia的秘密花园</a>！</span></div></div></article><div id="pagination"><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2019/10/11/h5c3-test/"><span>h5c3-test</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2019 By Andrelia</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>