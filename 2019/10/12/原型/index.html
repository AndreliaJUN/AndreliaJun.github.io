<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Andrelia,undefined"><meta name="copyright" content="Andrelia"><title>【Andrelia的秘密花园】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="icon" href="/favicon.ico"><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
}</script></head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript面向对象编程"><span class="toc-number">1.</span> <span class="toc-text">JavaScript面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是对象："><span class="toc-number">1.1.</span> <span class="toc-text">什么是对象：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是面向对象："><span class="toc-number">1.2.</span> <span class="toc-text">什么是面向对象：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象与面向过程："><span class="toc-number">1.3.</span> <span class="toc-text">面向对象与面向过程：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象的特性："><span class="toc-number">1.4.</span> <span class="toc-text">面向对象的特性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建对象的方法："><span class="toc-number">1.5.</span> <span class="toc-text">创建对象的方法：</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/sijia1.jpg"></div><div class="author-info-name">Andrelia</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/AndreliaJUN" target="_blank">GitHub<i class="icon-dot bg-color8"></i></a><a class="links-button button-hover" href="https://blog.csdn.net/Andrelia20171760" target="_blank">CSDN<i class="icon-dot bg-color3"></i></a><a class="links-button button-hover" href="http://www.andrelia.cn" target="_blank">PersonalSite<i class="icon-dot bg-color7"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">4</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">4</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">2</span></a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="title-name" href="/">Andrelia的秘密花园</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title"></div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-10-12 | 更新于 2019-10-12</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"></div><div class="button-hover tags"></div></div></div><div class="main-content"><h2 id="JavaScript面向对象编程"><a href="#JavaScript面向对象编程" class="headerlink" title="JavaScript面向对象编程"></a>JavaScript面向对象编程</h2><h3 id="什么是对象："><a href="#什么是对象：" class="headerlink" title="什么是对象："></a>什么是对象：</h3><p>ECMAScript-262 把对象定义为：<strong>无序属性的集合，其属性可以包含基本值、对象或者函数</strong>。</p>
<p>严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。</p>
<blockquote>
<p>提示：每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型。</p>
</blockquote>
<h3 id="什么是面向对象："><a href="#什么是面向对象：" class="headerlink" title="什么是面向对象："></a>什么是面向对象：</h3><blockquote>
<p>面向对象不是新的东西，它只是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。</p>
</blockquote>
<h3 id="面向对象与面向过程："><a href="#面向对象与面向过程：" class="headerlink" title="面向对象与面向过程："></a>面向对象与面向过程：</h3><ul>
<li><p>面向过程就是亲力亲为，事无巨细，面面俱到，步步紧跟，有条不紊</p>
</li>
<li><p>面向对象就是找一个对象，指挥得结果</p>
</li>
<li><p>面向对象将执行者转变成指挥者</p>
</li>
<li><p>面向对象不是面向过程的替代，而是面向过程的封装</p>
</li>
<li><p>面向过程注重过程，面向对象注重结果</p>
</li>
</ul>
<h3 id="面向对象的特性："><a href="#面向对象的特性：" class="headerlink" title="面向对象的特性："></a>面向对象的特性：</h3><ul>
<li>封装性</li>
<li>继承性</li>
<li>多态性</li>
</ul>
<p>在 JavaScript 中，所有数据类型都可以视为对象，当然也可以自定义对象。</p>
<p>自定义的对象数据类型就是面向对象中的类（ Class ）的概念。</p>
<h3 id="创建对象的方法："><a href="#创建对象的方法：" class="headerlink" title="创建对象的方法："></a>创建对象的方法：</h3><ul>
<li><p><strong>new Object()</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">'Jack'</span></span><br><span class="line">person.age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次都new比较麻烦，所以可以通过简写形式即对象字面量来创建。</p>
</li>
<li><p><strong>对象字面量方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的写法固然没有问题，但是假如我们要生成两个 <code>person</code> 实例对象呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span>,</span><br><span class="line">  age: <span class="number">18</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  name: <span class="string">'Mike'</span>,</span><br><span class="line">  age: <span class="number">16</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们不难看出，这样写的代码太过冗余，重复性太高。</p>
</li>
</ul>
<p>  <strong>简单方式的改进：工厂函数</strong></p>
<p>  我们可以写一个函数，解决代码重复问题：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  然后生成实例对象：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = createPerson(<span class="string">'Jack'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> p2 = createPerson(<span class="string">'Mike'</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p>  这样封装确实爽多了，通过工厂模式我们解决了创建多个相似对象代码冗余的问题，</p>
<p>  但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</p>
<p>  那么就有更优雅的工厂函数：构造函数。</p>
<ul>
<li><strong>自定义构造函数</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'Jack'</span>, <span class="number">18</span>)</span><br><span class="line">p1.sayName() <span class="comment">// =&gt; Jack</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'Mike'</span>, <span class="number">23</span>)</span><br><span class="line">p2.sayName() <span class="comment">// =&gt; Mike</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Person()</code> 函数取代了 <code>createPerson()</code> 函数，但是实现效果是一样的。</p>
<p><strong>工厂模式和自定义构造函数的相同点与不同点</strong></p>
<p>共同点:都是函数,都可以创建对象,都可以传入参数</p>
<p>不同点：</p>
<ul>
<li><p>工厂模式:</p>
<ul>
<li>函数名是小写</li>
<li>有new</li>
<li>有返回值</li>
<li>new之后的对象是当前的对象</li>
<li>直接调用函数就可以创建对象</li>
</ul>
</li>
<li><p>自定义构造函数:</p>
<ul>
<li>函数名是大写(首字母)</li>
<li>没有new</li>
<li>没有返回值</li>
<li>this是当前的对象</li>
<li>通过new的方式来创建对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>- 没有显示的创建对象</p>
<p>- 直接将属性和方法赋给了 <code>this</code> 对象</p>
<p>- 没有 <code>return</code> 语句</p>
<p>- 函数名使用的是大写的 <code>Person</code></p>
</blockquote>
<p><strong>调用构造函数创建实例会经历以下 4 个步骤：</strong></p>
<ol>
<li><p>开辟空间存储对象</p>
</li>
<li><p>把this设置为当前的对象</p>
</li>
</ol>
<p>​    3. 设置属性和方法的值</p>
<pre><code>4. 把this对象返回</code></pre><p><strong>构造函数和实例对象的关系</strong></p>
<p>使用构造函数的好处不仅仅在于代码的简洁性，更重要的是我们可以识别对象的具体类型了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,sex</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name=name;</span><br><span class="line">      <span class="keyword">this</span>.age=age;</span><br><span class="line">      <span class="keyword">this</span>.sex=sex;</span><br><span class="line">      <span class="keyword">this</span>.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"吃肉肉"</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> girl=<span class="keyword">new</span> Person(<span class="string">"小明"</span>,<span class="number">20</span>,<span class="string">"女"</span>);</span><br><span class="line">     <span class="built_in">console</span>.dir(girl);</span><br><span class="line">     <span class="built_in">console</span>.dir(Person);</span><br></pre></td></tr></table></figure>

<p>控制台显示如下：</p>
<img src="/2019/10/12/原型/1.png" style="zoom:75%;">

<p>在每一个实例对象中的__proto__中同时有一个 <code>constructor</code> 属性,，该属性指向创建该实例的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(girl.constructor==Person);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(girl.__proto__.constructor==Person);</span><br><span class="line">  <span class="built_in">console</span>.log(girl.__proto__.constructor==Person.prototype.constructor);</span><br><span class="line">  <span class="comment">//console.log(girl instanceof Person);</span></span><br></pre></td></tr></table></figure>

<p>以上控制台都打印true，代表这个实例对象girl就是通过Person来创建的。所以我们也可以用它来检测对象的类型。</p>
<p><strong>检测对象类型的方法</strong></p>
<ul>
<li><p>通过构造器的方式 实例对象.构造器==构造函数名字</p>
</li>
<li><p>对象 instanceof 构造函数名字</p>
</li>
</ul>
<p>​    *  尽可能的使用第二种方式来识别,为什么?原型讲完再说</p>
<p><strong>总结</strong></p>
<p>- 构造函数是根据具体的事物抽象出来的抽象模板</p>
<p>- 实例对象是根据抽象的构造函数模板得到的具体实例对象</p>
<p>- 每一个实例对象都具有一个 <code>constructor</code> 属性，指向创建该实例的构造函数</p>
<p>  + 注意： <code>constructor</code> 是实例的属性的说法不严谨，具体后面的原型会讲到</p>
<p>- 可以通过实例的 <code>constructor</code> 属性判断实例和构造函数之间的关系</p>
<p>  + 注意：这种方式不严谨，推荐使用 <code>instanceof</code> 操作符，后面学原型会解释为什么</p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Andrelia</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://andreliajun.github.io/2019/10/12/原型/">https://andreliajun.github.io/2019/10/12/原型/</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://andreliajun.github.io">Andrelia的秘密花园</a>！</span></div></div></article><div id="pagination"><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/2019/10/11/h5c3-test/"><span>h5c3-test</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2019 By Andrelia</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--></body></html>